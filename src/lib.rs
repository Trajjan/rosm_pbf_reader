//! A low-level library for parsing OSM data in PBF format.
//!
//! An OSM PBF file is a sequence of blobs. These blobs can be read with [`read_blob`]. The 
//! [`RawBlock`]s returned by `read_blob` can then be decompressed and parsed by 
//! [`BlockParser::parse_block`], which returns a [`Block`], containing either a parsed 
//! header/primitive block or an unknown block's binary data.
//!
//! The library also provides utilities for reading densely or delta encoded data in these blocks.
//!
//! Raw header and primitive block definitions (generated by `quick-protobuf`) are exported 
//! through the `pbf` module.
//!
//! # Links
//!
//! - [OSM PBF format documentation](https://wiki.openstreetmap.org/wiki/PBF_Format)

#[cfg(feature = "default")]
use flate2::read::ZlibDecoder;

mod proto;
use proto::osmformat::{DenseNodes, Info, StringTable};

use quick_protobuf::{BytesReader, MessageRead};

use std::convert::From;
#[cfg(feature = "default")]
use std::io::prelude::*;
use std::io::ErrorKind;
use std::str;
use std::str::Utf8Error;

pub mod util;

pub use proto::osmformat as pbf;

/// Possible errors returned by the library.
#[derive(Debug)]
pub enum Error {
    /// Returned when a PBF parse error has occured.
    PbfParseError(quick_protobuf::Error),
    /// Returned when reading from the input stream or decompression of blob data has failed.
    IoError(std::io::Error),
    /// Returned when a blob header with an invalid size (negative or >=64 KB) is encountered.
    InvalidBlobHeader,
    /// Returned when blob data with an invalid size (negative or >=32 MB) is encountered.
    InvalidBlobData,
    /// Returned when an error has occured during blob decompression.
    DecompressionError(DecompressionError),
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

/// Result of [`BlockParser::parse_block`].
pub enum Block<'a> {
    /// A raw `OSMHeader` block.
    Header(pbf::HeaderBlock<'a>),
    /// A raw `OSMData` (primitive) block.
    Primitive(pbf::PrimitiveBlock<'a>),
    /// An unknown block.
    Unknown(&'a [u8]),
}

enum BlockType {
    Header,
    Primitive,
    Unknown,
}

impl From<&str> for BlockType {
    fn from(value: &str) -> Self {
        match value {
            "OSMHeader" => BlockType::Header,
            "OSMData" => BlockType::Primitive,
            _ => BlockType::Unknown,
        }
    }
}

/// An unparsed, possibly compressed block.
pub struct RawBlock {
    r#type: BlockType,
    data: Vec<u8>,
}

/// Reads the next blob from `pbf`.
///
/// # Examples
///
/// ```no_run
/// use rosm_pbf_reader::read_blob;
///
/// use std::fs::File;
///
/// let mut file = File::open("some.osm.pbf").unwrap();
///
/// while let Some(result) = read_blob(&mut file) {
///     match result {
///         Ok(raw_block) => {}
///         Err(error) => {}
///     }
/// }
/// ```
pub fn read_blob<Input>(pbf: &mut Input) -> Option<Result<RawBlock, Error>>
where Input: std::io::Read
{
    use proto::fileformat::BlobHeader;

    let mut header_size_buffer = [0u8; 4];

    if let Err(error) = pbf.read_exact(&mut header_size_buffer) {
        return match error.kind() {
            ErrorKind::UnexpectedEof => None,
            _ => Some(Err(Error::IoError(error))),
        };
    }

    let blob_header_size = i32::from_be_bytes(header_size_buffer);

    if !(0..64 * 1024).contains(&blob_header_size) {
        return Some(Err(Error::InvalidBlobHeader));
    }

    let mut blob = vec![0u8; blob_header_size as usize];
    if let Err(error) = pbf.read_exact(&mut blob) {
        return Some(Err(Error::IoError(error)));
    }

    let mut header_reader = BytesReader::from_bytes(&blob);
    let blob_header = match BlobHeader::from_reader(&mut header_reader, &blob) {
        Ok(blob_header) => blob_header,
        Err(error) => return Some(Err(Error::PbfParseError(error))),
    };

    let block_type = BlockType::from(blob_header.type_pb.as_ref());
    let blob_size = blob_header.datasize;

    if !(0..32 * 1024 * 1024).contains(&blob_size) {
        return Some(Err(Error::InvalidBlobData));
    }

    blob.resize_with(blob_size as usize, Default::default);

    if let Err(error) = pbf.read_exact(&mut blob) {
        return Some(Err(Error::IoError(error)));
    }

    let raw_block = RawBlock {
        r#type: block_type,
        data: blob,
    };

    Some(Ok(raw_block))
}

/// Blob compression method.
pub enum CompressionMethod {
    /// LZ4
    Lz4,
    /// LZMA
    Lzma,
    /// ZLib
    Zlib,
    /// Zstandard
    Zstd,
}

/// Possible errors returned by [Decompressor] implementations.
#[derive(Debug)]
pub enum DecompressionError {
    /// The given compression method isn't supported by the decompressor.
    UnsupportedCompression,
    /// An internal error occured during decompression.
    InternalError(Box<dyn std::error::Error>),
}

/// Trait for custom decompression support.
pub trait Decompressor {
    /// Decompresses `input` blob into the preallocated `output` slice.
    fn decompress(method: CompressionMethod, input: &[u8], output: &mut [u8]) -> Result<(), DecompressionError>;
}

/// The default blob decompressor.
///
/// Supports ZLib decompression if default features are enabled.
pub struct DefaultDecompressor;

impl Decompressor for DefaultDecompressor {
    #[cfg(feature = "default")]
    fn decompress(method: CompressionMethod, input: &[u8], output: &mut [u8]) -> Result<(), DecompressionError> {
        match method {
            CompressionMethod::Zlib => {
                let mut decoder = ZlibDecoder::new(input.as_ref());

                match decoder.read_exact(output) {
                    Ok(_) => Ok(()),
                    Err(error) => Err(DecompressionError::InternalError(Box::new(error))),
                }
            }
            _ => Err(DecompressionError::UnsupportedCompression)
        }
    }

    #[cfg(not(feature = "default"))]
    fn decompress(_method: CompressionMethod, _input: &[u8], _output: &mut [u8]) -> Result<(), DecompressionError> {
        Err(DecompressionError::UnsupportedCompression)
    }
}

/// Parser with an internal buffer for `RawBlock`s.
///
/// When multiple threads are used to speed up parsing, it's recommended to use a single 
/// `BlockParser` per thread (e.g. by making it thread local), so its internal buffer remains
/// alive, avoiding repeated memory allocations.
pub struct BlockParser<D: Decompressor = DefaultDecompressor> {
    block_buffer: Vec<u8>,
    decompressor: std::marker::PhantomData<D>,
}

impl Default for BlockParser {
    fn default() -> Self {
        BlockParser::<DefaultDecompressor>::new()
    }
}

impl<D: Decompressor> BlockParser<D> {
    /// Creates a new `BlockParser`.
    pub fn new() -> Self {
        Self {
            block_buffer: Vec::new(),
            decompressor: Default::default(),
        }
    }

    /// Parses `raw_block` into a header, primitive or unknown block.
    #[allow(deprecated)]
    pub fn parse_block(&mut self, raw_block: RawBlock) -> Result<Block, Error> {
        use proto::fileformat::Blob;
        use proto::fileformat::mod_Blob::OneOfdata;

        let mut blob_reader = BytesReader::from_bytes(&raw_block.data);
        let blob = match Blob::from_reader(&mut blob_reader, &raw_block.data) {
            Ok(blob) => blob,
            Err(error) => return Err(Error::PbfParseError(error)),
        };

        if let Some(uncompressed_size) = blob.raw_size {
            self.block_buffer.resize_with(uncompressed_size as usize, Default::default);
        }

        match blob.data {
            OneOfdata::raw(raw_data) => self.block_buffer.extend_from_slice(&raw_data),
            OneOfdata::zlib_data(zlib_data) => {
                if let Err(error) = D::decompress(CompressionMethod::Zlib, &zlib_data, &mut self.block_buffer) {
                    return Err(Error::DecompressionError(error));
                }
            }
            OneOfdata::lz4_data(lz4_data) => {
                if let Err(error) = D::decompress(CompressionMethod::Lz4, &lz4_data, &mut self.block_buffer) {
                    return Err(Error::DecompressionError(error));
                }
            }
            OneOfdata::lzma_data(lzma_data) => {
                if let Err(error) = D::decompress(CompressionMethod::Lzma, &lzma_data, &mut self.block_buffer) {
                    return Err(Error::DecompressionError(error));
                }
            }
            OneOfdata::zstd_data(zstd_data) => {
                if let Err(error) = D::decompress(CompressionMethod::Zstd, &zstd_data, &mut self.block_buffer) {
                    return Err(Error::DecompressionError(error));
                }
            }
            OneOfdata::OBSOLETE_bzip2_data(_) | OneOfdata::None => return Err(Error::InvalidBlobData),
        }

        let mut block_reader = BytesReader::from_bytes(&self.block_buffer);

        match raw_block.r#type {
            BlockType::Header => match pbf::HeaderBlock::from_reader(&mut block_reader, &self.block_buffer) {
                Ok(header_block) => Ok(Block::Header(header_block)),
                Err(error) => Err(Error::PbfParseError(error)),
            },
            BlockType::Primitive => {
                match pbf::PrimitiveBlock::from_reader(&mut block_reader, &self.block_buffer) {
                    Ok(primitive_block) => Ok(Block::Primitive(primitive_block)),
                    Err(error) => Err(Error::PbfParseError(error)),
                }
            }
            BlockType::Unknown => Ok(Block::Unknown(&self.block_buffer)),
        }
    }
}

/// Utility for reading tags of dense nodes.
///
/// See [`DenseNode::tags`].
pub struct DenseTagReader<'a> {
    string_table: &'a StringTable<'a>,
    indices_it: std::slice::Iter<'a, i32>,
}

impl<'a> Iterator for DenseTagReader<'a> {
    type Item = (Result<&'a str, Utf8Error>, Result<&'a str, Utf8Error>);

    fn next(&mut self) -> Option<Self::Item> {
        match self.indices_it.next() {
            Some(key_index) => {
                let key = str::from_utf8(self.string_table.s[*key_index as usize].as_ref());

                let value_index = self.indices_it.next()?;
                let value = str::from_utf8(self.string_table.s[*value_index as usize].as_ref());

                Some((key, value))
            }
            None => None,
        }
    }
}

/// Utility for reading tags.
pub struct TagReader<'a> {
    string_table: &'a StringTable<'a>,
    key_indices: &'a [u32],
    value_indices: &'a [u32],
    idx: usize,
}

impl<'a> TagReader<'a> {
    /// Constructs a new `TagReader` from key and value index slices, and a corresponding string table.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use rosm_pbf_reader::{pbf, TagReader};
    ///
    /// fn process_primitive_block(block: pbf::PrimitiveBlock) {
    ///     for group in &block.primitivegroup {
    ///         for way in &group.ways {
    ///             let tags = TagReader::new(&way.keys, &way.vals, &block.stringtable);
    ///             for (key, value) in tags {
    ///                 println!("{}: {}", key.unwrap(), value.unwrap());
    ///             }
    ///         }
    ///     }
    /// }
    pub fn new(key_indices: &'a [u32], value_indices: &'a [u32], string_table: &'a StringTable<'a>) -> Self {
        TagReader {
            string_table,
            key_indices,
            value_indices,
            idx: 0,
        }
    }
}

impl<'a> Iterator for TagReader<'a> {
    type Item = (Result<&'a str, Utf8Error>, Result<&'a str, Utf8Error>);

    fn next(&mut self) -> Option<Self::Item> {
        if self.idx < self.key_indices.len() {
            let key = str::from_utf8(self.string_table.s[self.key_indices[self.idx] as usize].as_ref());
            let value = str::from_utf8(self.string_table.s[self.value_indices[self.idx] as usize].as_ref());

            self.idx += 1;

            Some((key, value))
        } else {
            None
        }
    }
}

/// An unpacked dense node, returned when iterating on [`DenseNodeReader`].
pub struct DenseNode<'a> {
    pub id: i64,
    pub lat: i64,
    pub lon: i64,
    pub tags: DenseTagReader<'a>,
    pub info: Option<Info>,
}

#[derive(Default)]
struct DeltaCodedValues {
    id: i64,
    lat: i64,
    lon: i64,
    timestamp: i64,
    changeset: i64,
    uid: i32,
    user_sid: i32,
}

/// Utility for reading delta-encoded dense nodes.
pub struct DenseNodeReader<'a> {
    data: &'a DenseNodes,
    string_table: &'a StringTable<'a>,
    data_idx: usize,
    key_value_idx: usize,      // Starting index of the next node's keys/values
    current: DeltaCodedValues, // Current values of delta coded fields
}

impl<'a> DenseNodeReader<'a> {
    /// Constructs a new `DenseNodeReader` from a slice of nodes.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use rosm_pbf_reader::{pbf, DenseNodeReader};
    ///
    /// fn process_primitive_block(block: pbf::PrimitiveBlock) {
    ///     for group in &block.primitivegroup {
    ///         if let Some(dense_nodes) = &group.dense {
    ///             let nodes = DenseNodeReader::new(&dense_nodes, &block.stringtable);
    ///             for node in nodes {
    ///                 for (key, value) in node.tags {
    ///                     println!("{}: {}", key.unwrap(), value.unwrap());
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    pub fn new(data: &'a DenseNodes, string_table: &'a StringTable<'a>) -> Self {
        DenseNodeReader {
            data,
            string_table,
            data_idx: 0,
            key_value_idx: 0,
            current: DeltaCodedValues::default(),
        }
    }
}

impl<'a> Iterator for DenseNodeReader<'a> {
    type Item = DenseNode<'a>;

    fn next(&mut self) -> Option<DenseNode<'a>> {
        if self.data_idx < self.data.id.len() {
            self.current.id += self.data.id[self.data_idx];
            self.current.lat += self.data.lat[self.data_idx];
            self.current.lon += self.data.lon[self.data_idx];

            let info = match &self.data.denseinfo {
                Some(dense_info) => {
                    // FIXME: seems like these arrays are always filled - it's not clear from the documentation if they can be empty or not
                    self.current.timestamp += dense_info.timestamp[self.data_idx];
                    self.current.changeset += dense_info.changeset[self.data_idx];
                    self.current.uid += dense_info.uid[self.data_idx];
                    self.current.user_sid += dense_info.user_sid[self.data_idx];

                    Some(Info {
                        version: dense_info.version[self.data_idx],
                        timestamp: Some(self.current.timestamp),
                        changeset: Some(self.current.changeset),
                        uid: Some(self.current.uid),
                        user_sid: Some(self.current.user_sid as u32), // u32 in the non-dense Info, an oversight in the specification
                        visible: dense_info.visible.get(self.data_idx).cloned(),
                    })
                }
                None => None,
            };

            let key_value_start = self.key_value_idx;

            for j in (self.key_value_idx..self.data.keys_vals.len()).step_by(2) {
                if self.data.keys_vals[j] == 0 {
                    self.key_value_idx = j + 1;
                    break; // Node end
                }
            }

            let key_value_slice = &self.data.keys_vals[key_value_start..self.key_value_idx - 1];
            assert!(key_value_slice.len() % 2 == 0);

            self.data_idx += 1;

            Some(DenseNode {
                id: self.current.id,
                lat: self.current.lat,
                lon: self.current.lon,
                tags: DenseTagReader {
                    string_table: self.string_table,
                    indices_it: key_value_slice.iter(),
                },
                info,
            })
        } else {
            None
        }
    }
}

/// Utility for reading delta-encoded values directly, like [`pbf::Way::refs`] and [`pbf::Relation::memids`].
pub struct DeltaValueReader<'a, T> {
    remaining: &'a [T],
    accumulated: T,
}

impl<'a, T> DeltaValueReader<'a, T>
where
    T: std::default::Default,
{
    /// Constructs a new `DeltaValueReader` from a slice of values.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use rosm_pbf_reader::{pbf, DeltaValueReader};
    ///
    /// fn process_primitive_block(block: pbf::PrimitiveBlock) {
    ///     for group in &block.primitivegroup {
    ///         for way in &group.ways {
    ///             let refs = DeltaValueReader::new(&way.refs);
    ///             for node_id in refs {
    ///                 println!("{}", node_id);
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    pub fn new(values: &'a [T]) -> Self {
        DeltaValueReader {
            remaining: values,
            accumulated: T::default(),
        }
    }
}

impl<'a, T> Iterator for DeltaValueReader<'a, T>
where
    T: std::ops::AddAssign + std::clone::Clone,
{
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some((first, elements)) = self.remaining.split_first() {
            self.accumulated += first.clone();
            self.remaining = elements;
            Some(self.accumulated.clone())
        } else {
            None
        }
    }
}

#[cfg(test)]
mod delta_value_reader_tests {
    use super::*;

    #[test]
    fn empty_input() {
        let mut reader = DeltaValueReader::new(&[] as &[i64]);
        assert_eq!(reader.next(), None);
    }

    #[test]
    fn valid_input() {
        let values = [10, -1, 4, -2];
        let mut reader = DeltaValueReader::new(&values);
        assert_eq!(reader.next(), Some(10));
        assert_eq!(reader.next(), Some(9));
        assert_eq!(reader.next(), Some(13));
        assert_eq!(reader.next(), Some(11));
    }
}
